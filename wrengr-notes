== Rewrite passes/transforms ==
* Ultrasimpl = perform all guaranteed-optimizations:
	* These are guaranteed to reduce the size of the term, no matter what the size-metric is.
    * involutions
	* idempotents
	* collapse Sum/Prod trees
	* constant propogation
	* ...

* Define passes for almost-surely optimizations:
	* These reduce the size of the term for some salient size-metric; but may conflict with one another by using different metrics
    * (a^c)*(b^c) ==> (a*b)^c
	* pushing homomorphisms down over Sum/Prod
	* pulling homomorphisms up over Sum/Prod

* Define partial-evaluation passes:
	* case-of-constructor (with let-binding of bound variables)
	* case-of-case (with let-binding, if appropriate)
	* affine beta-reductions
	* certain non-affine beta-reductions (via let-binding), to remove administrative redexes

* Convert to A-normal form?

* TODO: look at how GHC implements rewrite rules & inlining heuristics


== Program transformation API & operators ==
* select the maximal (e.g.) HBool expression rooted at this point ==> unselect when hitting primitives, like (<) or (==). 
	* This way we can hand the HBool expression off to a circuit minimization algorithm
	* Similar type-based selectors for other things (e.g., maximal non-Mochastic expression; maximal HSemiring expression;...)

* Solve a non-Mochastic expression for any given free variable. Or, at least segment it into the variable in some backward context and the rest in forward context

* Nanopass-style API operations?
	* catamorphism version of the "match" macro
* SYB? Generics? Other?

* Closure conversion (after free-variable analysis; which is performed by neelk's ABTs)
* liveness analysis (for register allocation) --- unnecessary if we compile to Haskell?


== Things to annotate at the fixed points ==
* the collection of free variables (a~la neelk's ABTs)
* the collection of "features" used (e.g., lambdas, other "impure" or "complicated" things)
	* cf., nanopass's "define-language" syntactic form
* whether the subexpression is in some given normal form, or optimized form
* hash-consing?
